<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Stock Forecast | Yugant Jha</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <div id="particles-js"></div>
  <div class="app-container">
    <header>
      <h1>Stock Price Forecast ðŸ“‰ </h1>
    </header>
    <section class="search-bar">
      <input type="text" id="symbolInput" placeholder="Search Stock Symbol (e.g. AAPL)" autocomplete="off" />
      <button id="searchBtn">Search</button>
      <ul id="suggestionsList" class="suggestions"></ul>
    </section>

     <section id="currentDisplay" class="current-display">
      <div style="display: flex; justify-content: center; align-items: center; gap: 12px; flex-wrap: wrap;">
      <h2 id="currentSymbol" style="margin: 0;">--</h2>
      <img id="stockLogo" style="height:60px;" />
     </div>
      <p>Current Price: <span id="currentPrice">--</span></p>
     <button id="forecastBtn" style="display:none;">View Forecast</button>
   </section>

    <section class="chart-section" style="display: none;">
      <canvas id="forecastChart"></canvas>
    </section>

    <section class="table-section" style="display: none;">
      <table id="forecastTable">
        <thead>
          <tr>
            <th>Date</th>
            <th>Open</th>
            <th>High</th>
            <th>Low</th>
            <th>Close</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </section>

    <!-- Floating SVGs Left -->
    <div class="floating-left">
      <!-- Bar Chart -->
      <svg class="float-svg" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="8" y="36" width="8" height="20" fill="#00cfff" />
        <rect x="20" y="28" width="8" height="28" fill="#00b5e0" />
        <rect x="32" y="20" width="8" height="36" fill="#008ecf" />
        <rect x="44" y="12" width="8" height="44" fill="#005f8f" />
      </svg>

      <!-- Line Chart Circle -->
      <svg class="float-svg small" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="32" cy="32" r="28" stroke="#00cfff" stroke-width="4" />
        <polyline points="16,40 26,28 36,38 46,24" stroke="#00b5e0" stroke-width="3" fill="none" />
      </svg>

      <!-- Pie Chart -->
      <svg class="float-svg small" viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg" fill="none" stroke="#00b5e0" stroke-width="3">
        <circle cx="32" cy="32" r="28" stroke-opacity="0.3"/>
        <path d="M32 32 L32 4 A28 28 0 1 1 60 40 Z" fill="#00cfff"/>
      </svg>

      <!-- Candlestick Chart -->
      <svg class="float-svg" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="14" y="18" width="6" height="28" fill="#00cfff"/>
        <rect x="24" y="24" width="6" height="22" fill="#008ecf"/>
        <rect x="34" y="14" width="6" height="32" fill="#00b5e0"/>
        <rect x="44" y="30" width="6" height="16" fill="#005f8f"/>
        <line x1="17" y1="10" x2="17" y2="58" stroke="#00cfff" stroke-width="1.5"/>
        <line x1="27" y1="10" x2="27" y2="58" stroke="#008ecf" stroke-width="1.5"/>
        <line x1="37" y1="10" x2="37" y2="58" stroke="#00b5e0" stroke-width="1.5"/>
        <line x1="47" y1="10" x2="47" y2="58" stroke="#005f8f" stroke-width="1.5"/>
      </svg>
    </div>

    <!-- Floating SVGs Right -->
    <div class="floating-right">
      <!-- Step Chart -->
      <svg class="float-svg" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <polyline points="8,48 16,48 16,36 24,36 24,20 32,20 32,28 40,28 40,16 48,16 48,44 56,44" stroke="#00cfff" stroke-width="4" fill="none"/>
      </svg>

      <!-- Circle with upward arrow -->
      <svg class="float-svg small" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <circle cx="32" cy="32" r="28" stroke="#00cfff" stroke-width="4" />
        <path d="M24 38 L32 26 L40 38" stroke="#00b5e0" stroke-width="3" fill="none" />
        <line x1="32" y1="26" x2="32" y2="46" stroke="#00b5e0" stroke-width="3"/>
      </svg>

      <!-- Dollar sign -->
      <svg class="float-svg small" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg" stroke="#00b5e0" stroke-width="3">
        <path d="M32 12 v40" />
        <path d="M22 20 h20 a6 6 0 1 1 0 24 h-20" />
      </svg>

      <!-- Bar + line combo -->
      <svg class="float-svg" viewBox="0 0 64 64" fill="none" xmlns="http://www.w3.org/2000/svg">
        <rect x="10" y="34" width="8" height="20" fill="#00cfff"/>
        <rect x="24" y="26" width="8" height="28" fill="#00b5e0"/>
        <rect x="38" y="18" width="8" height="36" fill="#008ecf"/>
        <polyline points="10,54 18,44 32,50 46,40 54,42" stroke="#00b5e0" stroke-width="3" fill="none" />
      </svg>
    </div>

    <section class="recent-section">
      <h3>Recently Searched</h3>
      <div id="recentList" class="recent-list"></div>
    </section>

    <footer class="footer">
      <div class="footer-content">
        <p>Â© Yugant Jha 2025 </p>
      </div>
    </footer>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/particles.js"></script>
  <script>
    particlesJS.load('particles-js', 'particles.json');
  </script>
  <script>
const isLocalhost = window.location.hostname === "127.0.0.1" || window.location.hostname === "localhost";
const BASE_URL = isLocalhost
  ? "http://127.0.0.1:8000"
  : "https://stockpriceforecast.fly.dev";  

let currentSymbol = "";
let priceInterval;
let currentPeriod = "1M";
let historicalData = [];
let forecastData = [];

async function fetchCurrentPrice(symbol) {
  try {
    const [priceRes, detailsRes] = await Promise.all([
      fetch(`${BASE_URL}/price?symbol=${symbol}`),
      fetch(`${BASE_URL}/details?symbol=${symbol}`)
    ]);

    const priceData = await priceRes.json();
    const detailsData = await detailsRes.json();

    const priceEl = document.getElementById("currentPrice");
    const symbolEl = document.getElementById("currentSymbol");

    if (priceData.error || detailsData.error) {
      priceEl.textContent = "N/A";
      symbolEl.textContent = "--";
      return;
    }

    priceEl.textContent = `$${priceData.price.toFixed(2)}`;
    symbolEl.textContent = `${detailsData.name} (${detailsData.symbol})`;

    // Display logo if available
    if (detailsData.logo) {
      let logo = document.getElementById("stockLogo");
      if (!logo) {
        logo = document.createElement("img");
        logo.id = "stockLogo";
        logo.style.height = "30px";
        logo.style.marginLeft = "10px";
        document.querySelector("#currentDisplay h2").appendChild(logo);
      }
      logo.src = detailsData.logo;
    }

    updateRecent(symbol, priceData.price);
  } catch (e) {
    document.getElementById("currentPrice").textContent = "N/A";
  }
}

function updateRecent(symbol, price) {
  let recent = JSON.parse(localStorage.getItem("recentStocks")) || [];
  recent = recent.filter(s => s.symbol !== symbol);
  recent.unshift({ symbol, price });
  if (recent.length > 5) recent.pop();
  localStorage.setItem("recentStocks", JSON.stringify(recent));
  renderRecent();
}

function renderRecent() {
  const container = document.getElementById("recentList");
  container.innerHTML = "";
  const recent = JSON.parse(localStorage.getItem("recentStocks")) || [];
  recent.forEach(stock => {
    const card = document.createElement("div");
    card.className = "recent-card";
    card.textContent = `${stock.symbol}: $${stock.price.toFixed(2)}`;
    card.addEventListener("click", () => {
      document.getElementById("symbolInput").value = stock.symbol;
      currentSymbol = stock.symbol;
      fetchCurrentPrice(stock.symbol);
      document.querySelector(".chart-section").style.display = "none";
      document.querySelector(".table-section").style.display = "none";
      document.getElementById("forecastBtn").style.display = "block";
    });
    container.appendChild(card);
  });
}

async function fetchHistoricalData(symbol, period) {
  try {
    const res = await fetch(`${BASE_URL}/historical?symbol=${symbol}&period=${period}`);
    const data = await res.json();
    
    if (data.error) {
      console.error("Error fetching historical data:", data.error);
      return [];
    }
    
    return data.historical || [];
  } catch (e) {
    console.error("Error fetching historical data:", e);
    return [];
  }
}

async function fetchForecast() {
  const symbol = currentSymbol;
  if (!symbol) return;
  
  try {
    // Fetch both historical and forecast data
    const [historicalRes, forecastRes] = await Promise.all([
      fetchHistoricalData(symbol, currentPeriod),
      fetch(`${BASE_URL}/forecast?symbol=${symbol}`)
    ]);
    
    historicalData = historicalRes;
    const forecastResult = await forecastRes.json();
    
    if (forecastResult.error) {
      alert(forecastResult.error);
      return;
    }
    
    forecastData = forecastResult.forecast || [];
    
    // Show time period buttons and chart
    showTimePeriodButtons();
    plotCombinedChart(historicalData, forecastData);
    buildForecastTable(forecastData);
    document.querySelector(".chart-section").style.display = "block";
    document.querySelector(".table-section").style.display = "block";
  } catch (e) {
    console.error("Error loading forecast:", e);
    alert("Error loading forecast");
  }
}

function showTimePeriodButtons() {
  // Check if buttons already exist
  if (document.querySelector('.time-period-buttons')) {
    return;
  }
  
  const chartSection = document.querySelector(".chart-section");
  const buttonContainer = document.createElement("div");
  buttonContainer.className = "time-period-buttons";
  buttonContainer.style.cssText = `
    display: flex;
    justify-content: center;
    gap: 10px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  `;
  
  const periods = ["1W", "1M", "3M", "6M", "1Y"];
  
  periods.forEach(period => {
    const button = document.createElement("button");
    button.textContent = period;
    button.className = period === currentPeriod ? "period-btn active" : "period-btn";
    button.style.cssText = `
      padding: 8px 16px;
      border: none;
      border-radius: 6px;
      background-color: ${period === currentPeriod ? '#00cfff' : '#444'};
      color: ${period === currentPeriod ? '#000' : '#fff'};
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    `;
    
    button.addEventListener("click", async () => {
      // Update active button
      document.querySelectorAll('.period-btn').forEach(btn => {
        btn.style.backgroundColor = '#444';
        btn.style.color = '#fff';
        btn.classList.remove('active');
      });
      button.style.backgroundColor = '#00cfff';
      button.style.color = '#000';
      button.classList.add('active');
      
      currentPeriod = period;
      
      // Fetch new historical data
      const newHistoricalData = await fetchHistoricalData(currentSymbol, period);
      historicalData = newHistoricalData;
      
      // Update chart
      plotCombinedChart(historicalData, forecastData);
    });
    
    buttonContainer.appendChild(button);
  });
  
  chartSection.insertBefore(buttonContainer, chartSection.firstChild);
}

function plotCombinedChart(historical, forecast) {
  const ctx = document.getElementById("forecastChart").getContext("2d");
  
  // Prepare historical data
  const historicalLabels = historical.map(d => d.date);
  const historicalOpen = historical.map(d => d.open);
  const historicalHigh = historical.map(d => d.high);
  const historicalLow = historical.map(d => d.low);
  const historicalClose = historical.map(d => d.close);
  
  // Prepare forecast data
  const forecastLabels = forecast.map(d => d.date);
  const forecastOpen = forecast.map(d => d.open);
  const forecastHigh = forecast.map(d => d.high);
  const forecastLow = forecast.map(d => d.low);
  const forecastClose = forecast.map(d => d.close);
  
  // Combine labels
  const allLabels = [...historicalLabels, ...forecastLabels];
  
  // Create datasets with null values to separate historical and forecast
  const createDataset = (historicalData, forecastData, label, color, forecastColor) => {
    const combinedData = [
      ...historicalData,
      ...new Array(forecastData.length).fill(null)
    ];
    
    const forecastDataset = [
      ...new Array(historicalData.length).fill(null),
      ...forecastData
    ];
    
    return [
      {
        label: `${label} (Historical)`,
        data: combinedData,
        borderColor: color,
        backgroundColor: color,
        fill: false,
        tension: 0.2,
        pointRadius: 1,
        pointHoverRadius: 4
      },
      {
        label: `${label} (Forecast)`,
        data: forecastDataset,
        borderColor: forecastColor,
        backgroundColor: forecastColor,
        fill: false,
        tension: 0.2,
        pointRadius: 2,
        pointHoverRadius: 5,
        borderDash: [5, 5], // Dashed line for forecast
        pointStyle: 'triangle'
      }
    ];
  };
  
  if (window.myChart) window.myChart.destroy();
  
  const datasets = [
    ...createDataset(historicalOpen, forecastOpen, "Open", "#ffa600", "#ffcc66"),
    ...createDataset(historicalHigh, forecastHigh, "High", "#00c853", "#66ff99"),
    ...createDataset(historicalLow, forecastLow, "Low", "#d50000", "#ff6666"),
    ...createDataset(historicalClose, forecastClose, "Close", "#4cffd4", "#80ffea")
  ];
  
  window.myChart = new Chart(ctx, {
    type: "line",
    data: {
      labels: allLabels,
      datasets: datasets
    },
    options: {
      responsive: true,
      interaction: { mode: 'index', intersect: false },
      plugins: {
        legend: { 
          labels: { color: "#fff" }, 
          position: 'top',
          onClick: function(e, legendItem) {
            const index = legendItem.datasetIndex;
            const chart = this.chart;
            const isVisible = chart.isDatasetVisible(index);
            chart.setDatasetVisibility(index, !isVisible);
            chart.update();
          }
        },
        tooltip: { 
          enabled: true, 
          mode: 'nearest',
          callbacks: {
            title: function(context) {
              return context[0].label;
            },
            label: function(context) {
              const datasetLabel = context.dataset.label;
              const value = context.parsed.y;
              return value !== null ? `${datasetLabel}: $${value.toFixed(2)}` : null;
            }
          }
        }
      },
      scales: {
        x: { 
          ticks: { color: "#ccc" },
          grid: { color: "#333" }
        },
        y: { 
          ticks: { 
            color: "#ccc",
            callback: function(value) {
              return '$' + value.toFixed(2);
            }
          },
          grid: { color: "#333" }
        }
      },
      animation: { duration: 1000, easing: 'easeOutQuart' }
    }
  });
}

function buildForecastTable(data) {
  const tbody = document.querySelector("#forecastTable tbody");
  const thead = document.querySelector("#forecastTable thead");
  thead.innerHTML = `
    <tr style="background-color:#222;color:white;">
      <th>Date</th>
      <th>Open</th>
      <th>High</th>
      <th>Low</th>
      <th>Close</th>
    </tr>`;
  tbody.innerHTML = "";
  data.forEach(row => {
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${row.date}</td>
      <td>$${row.open}</td>
      <td>$${row.high}</td>
      <td>$${row.low}</td>
      <td>$${row.close}</td>`;
    tr.style.transition = "background-color 0.3s";
    tr.onmouseover = () => tr.style.backgroundColor = "#333";
    tr.onmouseout = () => tr.style.backgroundColor = "";
    tbody.appendChild(tr);
  });
}

window.addEventListener("load", () => {
  renderRecent();
});

document.getElementById("searchBtn").addEventListener("click", () => {
  const symbolInput = document.getElementById("symbolInput");
  const symbol = symbolInput.value.trim().toUpperCase();
  if (!symbol) return;

  currentSymbol = symbol;

  document.querySelector(".chart-section").style.display = "none";
  document.querySelector(".table-section").style.display = "none";
  
  // Remove existing time period buttons
  const existingButtons = document.querySelector('.time-period-buttons');
  if (existingButtons) {
    existingButtons.remove();
  }

  const forecastBtn = document.getElementById("forecastBtn");
  forecastBtn.style.display = "block";

  fetchCurrentPrice(symbol);

  if (priceInterval) clearInterval(priceInterval);
  priceInterval = setInterval(() => fetchCurrentPrice(symbol), 30000);
});

document.getElementById("forecastBtn").addEventListener("click", fetchForecast);

// Dropdown Suggestions
const input = document.getElementById("symbolInput");
const dropdown = document.getElementById("suggestionsList");

input.addEventListener("input", async () => {
  const query = input.value.trim();
  if (query.length < 2) {
    dropdown.innerHTML = "";
    return;
  }

  try {
    const res = await fetch(`${BASE_URL}/search-symbol?query=${query}`);
    const data = await res.json();

    dropdown.innerHTML = "";
    data.results.forEach(({ symbol, name }) => {
      const li = document.createElement("li");
      li.textContent = `${symbol} - ${name}`;
      li.className = "dropdown-item";
      li.onclick = () => {
        input.value = symbol;
        dropdown.innerHTML = "";
      };
      dropdown.appendChild(li);
    });
  } catch (err) {
    dropdown.innerHTML = "";
  }
});
  </script>
</body>
</html>